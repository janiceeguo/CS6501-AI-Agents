1. ToolNode uses the asyncio event loop which calls the async functions. The await inside these functions allows other tools to run concurrently, so multiple tools can be called and run at the same time. The kind of tools that would benefit the most are input/output functions, such as API calls, HTTP scraping, LLM calls to different models, etc. because these kind of tasks spend most of their time waiting for the output to be generated, so async concurrency gives a big boost in speed.
2. The two programs handle special inputs in the input_node function, where state flags are set depending on the input. In the routing after parsing the input, these flags are checked and different actions (such as termination or asking for input again) are taken without calling the model or adding to chat history.
3. The main difference between ToolNode and the react agent is how the model interacts with the tools. In the ToolNode graph, the tools can be explicitly seen in a predefined loop. In the react agent graph however, it seems more black-box where the internal loop is hidden as the agent continuously reasons about which tools to use depending on the current state and the desired output.  
4. One example of when the LangChang react agent is too restrictive is when we want to execute a task of running 100 API calls and summarizing results. The toolnode approach is much better in this scenario because of its ability to run tools in parallel, rather than the react agent which would have to make 100 separate LLM calls sequentially. The react agent would be more beneficial in tasks where reasoning is needed.